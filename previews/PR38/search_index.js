var documenterSearchIndex = {"docs":
[{"location":"affinemap/#Affine-maps","page":"Affine maps","title":"Affine maps","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"An affine map is a function f given by","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":" f(x) = A x + b","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"where A is the slope and b is the intercept. Different representations of affine maps are sometimes useful, as documented below.","category":"page"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"affinemap/#Types","page":"Affine maps","title":"Types","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"AbstractAffineMap{T<:Number}\nAffineMap{T,U,V}\nLinearMap{T,U}\nAffineCorrector{T,U,V,S}","category":"page"},{"location":"affinemap/#MarkovKernels.AbstractAffineMap","page":"Affine maps","title":"MarkovKernels.AbstractAffineMap","text":"AbstractAffineMap{T<:Number}\n\nAbstract type for representing affine maps between vector spaces over the field determined by T.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.AffineMap","page":"Affine maps","title":"MarkovKernels.AffineMap","text":"AffineMap{T,U,V}\n\nType for representing affine maps in the standard slope / intercept parametrisation.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.LinearMap","page":"Affine maps","title":"MarkovKernels.LinearMap","text":"LinearMap{T,U}\n\nType for representing affine maps with zero intercept.\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#MarkovKernels.AffineCorrector","page":"Affine maps","title":"MarkovKernels.AffineCorrector","text":"AffineCorrector{T,U,V,S}\n\nType for representing affine correctors, i.e.,\n\nx ↦ b + A * (x -c).\n\n\n\n\n\n","category":"type"},{"location":"affinemap/#Constructors","page":"Affine maps","title":"Constructors","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"AffineMap(A::AbstractMatrix, b::AbstractVector)\nLinearMap(A::AbstractMatrix)\nAffineCorrector(A::AbstractMatrix, b::AbstractVector, c::AbstractVector)","category":"page"},{"location":"affinemap/#MarkovKernels.AffineMap-Tuple{AbstractMatrix, AbstractVector}","page":"Affine maps","title":"MarkovKernels.AffineMap","text":"AffineMap(A::AbstractMatrix, b::AbstractVector)\n\nCreates an AffineMap with slope A and intercept b.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.LinearMap-Tuple{AbstractMatrix}","page":"Affine maps","title":"MarkovKernels.LinearMap","text":"LinearMap(A::AbstractMatrix)\n\nCreates a LinearMap with slope A.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.AffineCorrector-Tuple{AbstractMatrix, AbstractVector, AbstractVector}","page":"Affine maps","title":"MarkovKernels.AffineCorrector","text":"AffineCorrector(A::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nCreates an Affine Corrector with slope A and intercept b - A * c.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#Basics","page":"Affine maps","title":"Basics","text":"","category":"section"},{"location":"affinemap/","page":"Affine maps","title":"Affine maps","text":"slope(F::AffineMap)\nintercept(F::AffineMap)\ncompose(F2::AbstractAffineMap, F1::AbstractAffineMap)\n*(F2::AbstractAffineMap, F1::AbstractAffineMap)","category":"page"},{"location":"affinemap/#MarkovKernels.slope-Tuple{AffineMap}","page":"Affine maps","title":"MarkovKernels.slope","text":"slope(F::AbstractAffineMap)\n\nComputes the slope of F.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.intercept-Tuple{AffineMap}","page":"Affine maps","title":"MarkovKernels.intercept","text":"intercept(F::AffineMap)\n\nComputes the intercept of F.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#MarkovKernels.compose-Tuple{AbstractAffineMap, AbstractAffineMap}","page":"Affine maps","title":"MarkovKernels.compose","text":"compose(F2::AbstractAffineMap, F1::AbstractAffineMap)\n\nComputes the affine map F3 resulting from the composition F2 ∘ F1.\n\n\n\n\n\n","category":"method"},{"location":"affinemap/#Base.:*-Tuple{AbstractAffineMap, AbstractAffineMap}","page":"Affine maps","title":"Base.:*","text":"*(F2::AbstractAffineMap, F1::AbstractAffineMap)\n\nEquivalent to compose(F2::AbstractAffineMap, F1::AbstractAffineMap).\n\n\n\n\n\n","category":"method"},{"location":"tutorial_pomp_sampling/#Sampling-from-Markov-realisable-processes","page":"Sampling from probabilistic state-space models","title":"Sampling from Markov-realisable processes","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"This tutorial describes how to sample from the probabilistic state-space model given by","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"beginaligned\nx_0 sim mathcalN(mu_0 Sigma_0) \nx_n mid x_n-1 sim mathcalN(Phi  x_n-1 Q)\ny_n = C x_n\nendaligned","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"where x and y are referred to as the latent Gauss-Markov process and the output process, respectively. Additionally, noisy measurements of the output process will be generated according to","category":"page"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"z_n mid x_n sim mathcalN(Cx_nR)","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-a-Gauss-Markov-process","page":"Sampling from probabilistic state-space models","title":"Sampling a Gauss-Markov process","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"using MarkovKernels\nusing Random, LinearAlgebra, Plots\n\nfunction sample(\n    RNG::AbstractRNG,\n    init::AbstractDistribution,\n    K::AbstractMarkovKernel,\n    nstep::Integer,\n)\n    x = rand(RNG, init)\n    xs = zeros(nstep + 1, length(x))\n    xs[1, :] = x\n\n    for n in 1:nstep\n        x = rand(RNG, K, x)\n        xs[n+1, :] = x\n    end\n\n    return xs\nend\n\nfunction sample(init::AbstractDistribution, K::AbstractMarkovKernel, nstep::Integer)\n    return sample(GLOBAL_RNG, init, K, nstep)\nend","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-latent-states","page":"Sampling from probabilistic state-space models","title":"Sampling latent states","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"# set an rng\nrng = MersenneTwister(1991)\n\n# time grid\nm = 100\nT = 5\nts = collect(LinRange(0, T, m))\ndt = T / (m - 1)\n\n# define transtion kernel\nλ = 2.0\nΦ = exp(-λ * dt) .* [1.0 0.0; -2*λ*dt 1.0]\nQ = I - exp(-2 * λ * dt) .* [1.0 -2*λ*dt; -2*λ*dt 1+(2*λ*dt)^2]\nfw_kernel = NormalKernel(Φ, Q)\n\n# initial distribution\ninit = Normal(zeros(2), 1.0I)\n\n# sample state\nxs = sample(rng, init, fw_kernel, m - 1)\n\nstate_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = \"t\",\n    labels = [\"x1\" \"x2\"],\n    title = [\"Latent Gauss-Markov process\" \"\"],\n)","category":"page"},{"location":"tutorial_pomp_sampling/#Sampling-and-plotting-the-output","page":"Sampling from probabilistic state-space models","title":"Sampling and plotting the output","text":"","category":"section"},{"location":"tutorial_pomp_sampling/","page":"Sampling from probabilistic state-space models","title":"Sampling from probabilistic state-space models","text":"# output kernel and measurement kernel\nC = 1.0 / sqrt(2) * [1.0 -1.0]\noutput_kernel = DiracKernel(C)\nR = fill(0.1, 1, 1)\nm_kernel = compose(NormalKernel(1.0I(1), R), output_kernel)\n\n# sample output and its measurements\nouts = mapreduce(z -> rand(rng, output_kernel, xs[z, :]), vcat, 1:m)\nys = mapreduce(z -> rand(rng, m_kernel, xs[z, :]), vcat, 1:m)\n\noutput_plot = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")\noutput_plot","category":"page"},{"location":"likelihoods/#LogLike","page":"LogLikelihoods","title":"LogLike","text":"","category":"section"},{"location":"likelihoods/","page":"LogLikelihoods","title":"LogLikelihoods","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"likelihoods/#Types","page":"LogLikelihoods","title":"Types","text":"","category":"section"},{"location":"likelihoods/","page":"LogLikelihoods","title":"LogLikelihoods","text":"LogLike{U,V}","category":"page"},{"location":"likelihoods/#MarkovKernels.LogLike","page":"LogLikelihoods","title":"MarkovKernels.LogLike","text":"LogLike{U,V}\n\nType for representing a log-likelihood associated with a kernel K(y, x) and a measurement y.\n\n\n\n\n\n","category":"type"},{"location":"likelihoods/#Constructors","page":"LogLikelihoods","title":"Constructors","text":"","category":"section"},{"location":"likelihoods/","page":"LogLikelihoods","title":"LogLikelihoods","text":"LogLike(K::AbstractMarkovKernel, y)","category":"page"},{"location":"likelihoods/#MarkovKernels.LogLike-Tuple{AbstractMarkovKernel, Any}","page":"LogLikelihoods","title":"MarkovKernels.LogLike","text":"LogLike(K::AbstractMarkovKernel, y)\n\nCreates a LogLike with measurement kernel K and measurement y.\n\n\n\n\n\n","category":"method"},{"location":"likelihoods/#Basics","page":"LogLikelihoods","title":"Basics","text":"","category":"section"},{"location":"likelihoods/","page":"LogLikelihoods","title":"LogLikelihoods","text":"measurement_model(L::LogLike)\nmeasurement(L::LogLike)","category":"page"},{"location":"likelihoods/#MarkovKernels.measurement_model-Tuple{LogLike}","page":"LogLikelihoods","title":"MarkovKernels.measurement_model","text":"measurement_model(L::LogLike)\n\nComputes the measurement kernel K.\n\n\n\n\n\n","category":"method"},{"location":"likelihoods/#MarkovKernels.measurement-Tuple{LogLike}","page":"LogLikelihoods","title":"MarkovKernels.measurement","text":"measurement(L::LogLike)\n\nComputes the measurement y\n\n\n\n\n\n","category":"method"},{"location":"dirac/#Dirac","page":"Dirac","title":"Dirac","text":"","category":"section"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"The Dirac distribution with parameter mu is a distribution putting all probabiltiy mass on mu. It is denoted by","category":"page"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"delta(x -mu)","category":"page"},{"location":"dirac/#Types","page":"Dirac","title":"Types","text":"","category":"section"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"AbstractDirac{T}\nDirac{T}","category":"page"},{"location":"dirac/#MarkovKernels.AbstractDirac","page":"Dirac","title":"MarkovKernels.AbstractDirac","text":"AbstractDirac{T<:Number}\n\nAbstract type for representing Dirac random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"dirac/#MarkovKernels.Dirac","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac{T<:Number}\n\nType for representing Dirac random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"dirac/#Constructors","page":"Dirac","title":"Constructors","text":"","category":"section"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"Dirac(μ::AbstractVector)\nDirac{T}(D::Dirac{U,V}) where {T,U,V<:AbstractVector}","category":"page"},{"location":"dirac/#MarkovKernels.Dirac-Tuple{AbstractVector}","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac(μ::AbstractVector)\n\nCreates a Dirac distribution with mean vector μ.\n\n\n\n\n\n","category":"method"},{"location":"dirac/#MarkovKernels.Dirac-Union{Tuple{Dirac{U, V}}, Tuple{V}, Tuple{U}, Tuple{T}} where {T, U, V<:(AbstractVector)}","page":"Dirac","title":"MarkovKernels.Dirac","text":"Dirac{T}(D::Dirac{U,V})\n\nComputes a Dirac distribution of eltype T from the Dirac distribution D if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"dirac/#Basics","page":"Dirac","title":"Basics","text":"","category":"section"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"dim(::Dirac)\nmean(::Dirac)\ncov(::AbstractDirac)\nvar(::AbstractDirac)\nstd(::AbstractDirac)","category":"page"},{"location":"dirac/#MarkovKernels.dim-Tuple{Dirac}","page":"Dirac","title":"MarkovKernels.dim","text":"dim(D::AbstractDirac)\n\nReturns the dimension of the Dirac distribution D.\n\n\n\n\n\n","category":"method"},{"location":"dirac/#Statistics.mean-Tuple{Dirac}","page":"Dirac","title":"Statistics.mean","text":"mean(D::AbstractDirac)\n\nComputes the mean vector of the Dirac distribution D.\n\n\n\n\n\n","category":"method"},{"location":"dirac/#Sampling","page":"Dirac","title":"Sampling","text":"","category":"section"},{"location":"dirac/","page":"Dirac","title":"Dirac","text":"rand(::AbstractRNG, ::AbstractDirac)\nrand( ::AbstractDirac)","category":"page"},{"location":"dirac/#Base.rand-Tuple{Random.AbstractRNG, AbstractDirac}","page":"Dirac","title":"Base.rand","text":"rand(RNG::AbstractRNG, D::AbstractDirac)\n\nComputes a random vector distributed according to the Dirac distribution D using the random number generator RNG. Equivalent to mean(D).\n\n\n\n\n\n","category":"method"},{"location":"dirac/#Base.rand-Tuple{AbstractDirac}","page":"Dirac","title":"Base.rand","text":"rand(D::AbstractDirac)\n\nComputes a random vector distributed according to the Dirac distribution D using the random number generator Random.GLOBAL_RNG. Equivalent to mean(D).\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#NormalKernel","page":"NormalKernel","title":"NormalKernel","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"The Normal kernel is denoted by","category":"page"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"k(ymid x) = mathcalN(y  mu(x)   Sigma(x) )","category":"page"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"As with the Normal distributions, the explicit expression on the kernel depends on whether it is real or complex valued.","category":"page"},{"location":"normalkernel/#Types","page":"NormalKernel","title":"Types","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"AbstractNormalKernel{T}\nNormalKernel{T}","category":"page"},{"location":"normalkernel/#MarkovKernels.AbstractNormalKernel","page":"NormalKernel","title":"MarkovKernels.AbstractNormalKernel","text":"AbstractNormalKernel{T<:Number}\n\nAbstract type for representing Normal kernels taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"normalkernel/#MarkovKernels.NormalKernel","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel\n\nStandard mean vector / covariance matrix parametrisation of Normal kernels.\n\n\n\n\n\n","category":"type"},{"location":"normalkernel/#Type-aliases","page":"NormalKernel","title":"Type aliases","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"const AffineNormalKernel{T} = NormalKernel{T,<:AbstractAffineMap,<:CovarianceParameter}","category":"page"},{"location":"normalkernel/#Constructors","page":"NormalKernel","title":"Constructors","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ)\nNormalKernel(Φ::AbstractMatrix, Σ)\nNormalKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\nNormalKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\nNormalKernel(F::AbstractAffineMap, Σ::CovarianceParameter)\nNormalKernel(F::AbstractAffineMap, Σ::AbstractMatrix)\nNormalKernel{T}(K::AffineNormalKernel{U}) where {T,U}","category":"page"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ)\n\nCreates a NormalKernel with conditional mean function F and conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with F.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, Σ)\n\nCreates a NormalKernel with a linear conditional mean function given by\n\nx ↦ Φ * x,\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, AbstractVector, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\n\nCreates a NormalKernel with an affine conditional mean function given by\n\nx ↦ b + Φ * x,\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ, b.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractMatrix, AbstractVector, AbstractVector, Any}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\n\nCreates a NormalKernel with an affine corrector conditional mean function given by\n\nx ↦ b + Φ * (x - c),\n\nand conditional covariance function parameter Σ. Σ is assumed to be callable and be of compatible eltype with Φ, b, c.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, Union{LinearAlgebra.Factorization{T}, LinearAlgebra.UniformScaling{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ::CovarianceParameter)\n\nCreates a NormalKernel with conditional mean function F and a constant conditional covariance function parameterised by Σ.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Tuple{AbstractAffineMap, AbstractMatrix}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel(F::AbstractAffineMap, Σ::AbstractMatrix)\n\nCreates a NormalKernel with conditional mean function F and a constant conditional covariance function Σ if Σ is Symmetric / Hermitian. Throws domain error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.NormalKernel-Union{Tuple{AffineNormalKernel{U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"NormalKernel","title":"MarkovKernels.NormalKernel","text":"NormalKernel{T}(K::AffineNormalKernel{U}) where {T,U}\n\nComputes a Normal kernel of eltype T from the Normal kernel K if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#Basics","page":"NormalKernel","title":"Basics","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"mean(K::NormalKernel)\ncov(K::NormalKernel)\ncovp(K::NormalKernel)","category":"page"},{"location":"normalkernel/#Statistics.mean-Tuple{NormalKernel}","page":"NormalKernel","title":"Statistics.mean","text":"mean(K::AbstractNormalKernel)\n\nComputes the conditonal mean function of the Normal kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#Statistics.cov-Tuple{NormalKernel}","page":"NormalKernel","title":"Statistics.cov","text":"mean(K::AbstractNormalKernel)\n\nComputes the conditonal covariance matrix function of the Normal kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#MarkovKernels.covp-Tuple{NormalKernel}","page":"NormalKernel","title":"MarkovKernels.covp","text":"covp(K::AbstractNormalKernel)\n\nReturns the internal representation of the conditonal covariance matrix of the Normal kernel K. For computing the actual conditional covariance matrix, use cov.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#Conditioning-and-sampling","page":"NormalKernel","title":"Conditioning and sampling","text":"","category":"section"},{"location":"normalkernel/","page":"NormalKernel","title":"NormalKernel","text":"condition(K::AbstractNormalKernel, x)\nrand(RNG::AbstractRNG, K::AbstractNormalKernel, x::AbstractVector)\nrand(K::AbstractNormalKernel, x::AbstractVector)","category":"page"},{"location":"normalkernel/#MarkovKernels.condition-Tuple{AbstractNormalKernel, Any}","page":"NormalKernel","title":"MarkovKernels.condition","text":"condition(K::AbstractNormalKernel, x)\n\nReturns a Normal distribution corresponding to K evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#Base.rand-Tuple{Random.AbstractRNG, AbstractNormalKernel, AbstractVector}","page":"NormalKernel","title":"Base.rand","text":"rand(RNG::AbstractRNG, K::AbstractNormalKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Normal kernel K using the random number generator RNG.\n\n\n\n\n\n","category":"method"},{"location":"normalkernel/#Base.rand-Tuple{AbstractNormalKernel, AbstractVector}","page":"NormalKernel","title":"Base.rand","text":"rand(K::AbstractNormalKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Normal kernel K using the random number generator Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"binary_operators/#composition","page":"Binary operators","title":"composition","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given Markov kernels k_2(yz) and k_1(zx), composition is a binary operator producing a third kernel k_3(yx) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"k_3(yx) = int k_2(yx) k_1(zx) mathrmd z","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"compose(K2::AffineNormalKernel{T}, K1::AffineNormalKernel{T}) where {T}","category":"page"},{"location":"binary_operators/#MarkovKernels.compose-Union{Tuple{T}, Tuple{AffineNormalKernel{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.compose","text":"compose(K2::AbstractMarkovKernel, K1::AbstractMarkovKernel)\n\nComputes K3, the composition of K2 ∘ K1 i.e.,\n\nK3(y,x) = ∫ K2(y,z) K1(z,x) dz.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#marginalisation","page":"Binary operators","title":"marginalisation","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given a distribution pi(x) and a Markov kernel k(yx), marginalisation is a binary operator producing a new distriubution p(y) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"p(y) = int k(y x) pi(x) mathrmd x","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"marginalise(N::AbstractNormal{T}, K::AffineNormalKernel{T}) where {T}","category":"page"},{"location":"binary_operators/#MarkovKernels.marginalise-Union{Tuple{T}, Tuple{AbstractNormal{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.marginalise","text":"marginalise(D::AbstractDistribution, K::AbstractMarkovKernel)\n\nComputes M, the marginalisation of K with respect to D, i.e.,\n\nM(y) = ∫ K(y,x)D(x) dx\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#invert-and-Bayes'-rule","page":"Binary operators","title":"invert & Bayes' rule","text":"","category":"section"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"Given a distribution pi(x) and a Markov kernel k(yx), invert is a binary operator producing a new distribution m(y) and a new Markov kernel p(x  y) according to","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"pi(x) k(yx) = m(y) p(xy)","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"The related binary operator, Bayes' rule also evalautes the output of invert at some measurement y. That is, given a measurmeent y, m evaluated at y is the marginal likelihood and p evaluated at y is the conditional distribution of x given y.","category":"page"},{"location":"binary_operators/","page":"Binary operators","title":"Binary operators","text":"invert(N::AbstractNormal{T}, K::AffineNormalKernel{T}) where {T}\nbayes_rule(D::AbstractDistribution, K::AbstractMarkovKernel, y)\nbayes_rule(D::AbstractDistribution, L::AbstractLogLike)","category":"page"},{"location":"binary_operators/#MarkovKernels.invert-Union{Tuple{T}, Tuple{AbstractNormal{T}, AffineNormalKernel{T}}} where T","page":"Binary operators","title":"MarkovKernels.invert","text":"invert(D::AbstractDistribution, K::AbstractMarkovKernel)\n\nComputes D2, K2, such that D(x)K(y, x) = D2(y)K2(x, y), i.e., an inverted factorisation of D, K.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#MarkovKernels.bayes_rule-Tuple{AbstractDistribution, AbstractMarkovKernel, Any}","page":"Binary operators","title":"MarkovKernels.bayes_rule","text":"bayes_rule(D::AbstractDistribution, K::AbstractMarkovKernel, y)\n\nComputes the conditional distribution C and the marginal log-likelihood ℓ associated with the prior distribution D, measurement kernel K, and measurement y.\n\n\n\n\n\n","category":"method"},{"location":"binary_operators/#MarkovKernels.bayes_rule-Tuple{AbstractDistribution, AbstractLogLike}","page":"Binary operators","title":"MarkovKernels.bayes_rule","text":"bayes_rule(D::AbstractDistribution, L::AbstractLogLike)\n\nComputes the conditional distribution C and the marginal log-likelihood ℓ associated with the prior distribution D and the log-likelihood L.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Normal","page":"Normal","title":"Normal","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"The standard parametrisation of the Normal distribution is given by","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma )","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"where mu is the mean vector and Sigma is the covariance matrix. The exact expression for the probabiltiy density function depends on whether x is vector with real or complex values, both are supported. For real valued vectors the density function is given by","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma ) = 2pi Sigma^-12 exp Big(  -frac12(x-mu)^* Sigma^-1 (x-mu)  Big)","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"whereas for complex valued vectors the density function is given by","category":"page"},{"location":"normal/","page":"Normal","title":"Normal","text":"mathcalN(x  mu   Sigma ) = pi Sigma^-1 exp Big(  -(x-mu)^* Sigma^-1 (x-mu)  Big)","category":"page"},{"location":"normal/#Types","page":"Normal","title":"Types","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"AbstractNormal{T}\nNormal{T}","category":"page"},{"location":"normal/#MarkovKernels.AbstractNormal","page":"Normal","title":"MarkovKernels.AbstractNormal","text":"AbstractNormal{T<:Number}\n\nAbstract type for representing Normal distributed random vectors taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"normal/#MarkovKernels.Normal","page":"Normal","title":"MarkovKernels.Normal","text":"Normal{T,U,V}\n\nStandard mean vector / covariance matrix parametrisation of the normal distribution with element type T.\n\n\n\n\n\n","category":"type"},{"location":"normal/#Type-aliases","page":"Normal","title":"Type aliases","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"const IsoNormal{T,U} = Normal{T,U,<:UniformScaling}","category":"page"},{"location":"normal/#Constructors","page":"Normal","title":"Constructors","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"Normal(μ::AbstractVector, Σ::CovarianceParameter)\nNormal(μ::AbstractVector, Σ::AbstractMatrix)\nIsoNormal(μ::AbstractVector, λ::Real)\nNormal{T}(N::Normal{U,V,W}) where {T,U,V<:AbstractVector,W<:CovarianceParameter}","category":"page"},{"location":"normal/#MarkovKernels.Normal-Tuple{AbstractVector, Union{LinearAlgebra.Factorization{T}, LinearAlgebra.UniformScaling{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal(μ::AbstractVector, Σ::CovarianceParameter)\n\nCreates a Normal distribution with mean vector μ and covariance matrix parametrised by Σ.\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.Normal-Tuple{AbstractVector, AbstractMatrix}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal(μ::AbstractVector, Σ::AbstractMatrix)\n\nCreates a Normal distribution with mean vector μ and covariance matrix Σ if Σ is Symmetric / Hermitian. Throws domain error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.IsoNormal-Tuple{AbstractVector, Real}","page":"Normal","title":"MarkovKernels.IsoNormal","text":"IsoNormal(μ::AbstractVector, λ::Real)\n\nShort-hand for Normal(μ, λ * I).\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.Normal-Union{Tuple{Normal{U, V, W}}, Tuple{W}, Tuple{V}, Tuple{U}, Tuple{T}} where {T, U, V<:(AbstractVector), W<:(Union{LinearAlgebra.Factorization{T}, LinearAlgebra.UniformScaling{T}, Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S} where T)}","page":"Normal","title":"MarkovKernels.Normal","text":"Normal{T}(N::Normal{U,V,W})\n\nComputes a Normal distribution of eltype T from the Normal distribution N if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Basics","page":"Normal","title":"Basics","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"dim(::Normal)\nmean(::Normal)\ncov(::Normal)\ncovp(::Normal)\nvar(::AbstractNormal)\nstd(::AbstractNormal)","category":"page"},{"location":"normal/#MarkovKernels.dim-Tuple{Normal}","page":"Normal","title":"MarkovKernels.dim","text":"dim(N::AbstractNormal)\n\nReturns the dimension of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Statistics.mean-Tuple{Normal}","page":"Normal","title":"Statistics.mean","text":"mean(N::AbstractNormal)\n\nComputes the mean vector of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Statistics.cov-Tuple{Normal}","page":"Normal","title":"Statistics.cov","text":"cov(N::AbstractNormal)\n\nComputes the covariance matrix of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.covp-Tuple{Normal}","page":"Normal","title":"MarkovKernels.covp","text":"covp(N::AbstractNormal)\n\nReturns the internal representation of the covariance matrix of the Normal distribution N. For computing the actual covariance matrix, use cov.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Statistics.var-Tuple{AbstractNormal}","page":"Normal","title":"Statistics.var","text":"var(N::AbstractNormal)\n\nComputes the vector of marginal variances of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Statistics.std-Tuple{AbstractNormal}","page":"Normal","title":"Statistics.std","text":"std(N::AbstractNormal)\n\nComputes the vector of marginal standard deviations of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Probability-density-function","page":"Normal","title":"Probability density function","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"residual(N::AbstractNormal, x::AbstractVector)\nlogpdf(N::AbstractNormal, x)","category":"page"},{"location":"normal/#MarkovKernels.residual-Tuple{AbstractNormal, AbstractVector}","page":"Normal","title":"MarkovKernels.residual","text":"residual(N::AbstractNormal, x::AbstractVector)\n\nComputes the whitened residual associated with the Normal distribution N and observed vector x.\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.logpdf-Tuple{AbstractNormal, Any}","page":"Normal","title":"MarkovKernels.logpdf","text":"logpdf(N::AbstractNormal,x)\n\nComputes the logarithm of the probability density function of the Normal distribution N evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Information-theory","page":"Normal","title":"Information theory","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"entropy(::AbstractNormal)\nkldivergence(N1::AbstractNormal{T}, N2::AbstractNormal{T}) where {T<:Number}","category":"page"},{"location":"normal/#MarkovKernels.entropy-Tuple{AbstractNormal}","page":"Normal","title":"MarkovKernels.entropy","text":"entropy(N::AbstractNormal)\n\nComputes the entropy of the Normal distribution N.\n\n\n\n\n\n","category":"method"},{"location":"normal/#MarkovKernels.kldivergence-Union{Tuple{T}, Tuple{AbstractNormal{T}, AbstractNormal{T}}} where T<:Number","page":"Normal","title":"MarkovKernels.kldivergence","text":"kldivergence(N1::AbstractNormal, N2::AbstractNormal)\n\nComputes the Kullback-Leibler divergence between the Normal distributions N1 and N2.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Sampling","page":"Normal","title":"Sampling","text":"","category":"section"},{"location":"normal/","page":"Normal","title":"Normal","text":"rand(::AbstractRNG, ::AbstractNormal)\nrand( ::AbstractNormal)","category":"page"},{"location":"normal/#Base.rand-Tuple{Random.AbstractRNG, AbstractNormal}","page":"Normal","title":"Base.rand","text":"rand(RNG::AbstractRNG, N::AbstractNormal)\n\nComputes a random vector distributed according to the Normal distribution N using the random number generator RNG.\n\n\n\n\n\n","category":"method"},{"location":"normal/#Base.rand-Tuple{AbstractNormal}","page":"Normal","title":"Base.rand","text":"rand(N::AbstractNormal)\n\nComputes a random vector distributed according to the Normal distribution N using the random number generator Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"method"},{"location":"tutorial_kalman_filter/#Implementing-a-Kalman-filter","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"tutorial_kalman_filter/#Setting-up-the-environment-and-loading-some-data","page":"Implementing a Kalman filter","title":"Setting up the environment and loading some data","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"using MarkovKernels\nusing Random, LinearAlgebra, Plots\n\nrng = MersenneTwister(1991)\n\ninclude(\"../../demo/sampling_implementation.jl\")\ninclude(\"../../demo/sample_trajectory.jl\")\n\noutput_plot = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")","category":"page"},{"location":"tutorial_kalman_filter/#Implementing-a-Kalman-filter-2","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"function kalman_filter(\n    ys::AbstractVecOrMat,\n    init::AbstractNormal,\n    fw_kernel::AbstractNormalKernel,\n    m_kernel::AbstractNormalKernel,\n)\n    n = size(ys, 1)\n\n    # initialise recursion\n    filter_distribution = init\n    filter_distributions = Normal[]      # filtering distributions\n\n    # create measurement model\n    y = ys[1, :]\n    likelihood = LogLike(m_kernel, y)\n\n    # measurement update\n    filter_distribution, loglike_increment = bayes_rule(filter_distribution, likelihood)\n    push!(filter_distributions, filter_distribution)\n    loglike = loglike_increment\n\n    for m in 2:n\n\n        # predict\n        filter_distribution = marginalise(filter_distribution, fw_kernel)\n\n        # create measurement model\n        y = ys[m, :]\n        likelihood = LogLike(m_kernel, y)\n\n        # measurement update\n        filter_distribution, loglike_increment = bayes_rule(filter_distribution, likelihood)\n\n        push!(filter_distributions, filter_distribution)\n        loglike = loglike + loglike_increment\n    end\n\n    return filter_distributions, loglike\nend","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-state-estimates","page":"Implementing a Kalman filter","title":"Computing the state estimates","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"filter_distributions, loglike = kalman_filter(ys, init, fw_kernel, m_kernel)\n\nstate_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = [\"\" \"t\"],\n    label = [\"x1\" \"x2\"],\n    title = [\"Filter estimates of the state\" \"\"],\n)\nplot!(ts, filter_distributions, layout = (2, 1), label = [\"x1filter\" \"x2filter\"])\n\nstate_plt","category":"page"},{"location":"tutorial_kalman_filter/#Computing-the-output-estimates","page":"Implementing a Kalman filter","title":"Computing the output estimates","text":"","category":"section"},{"location":"tutorial_kalman_filter/","page":"Implementing a Kalman filter","title":"Implementing a Kalman filter","text":"output_filter_estimate = map(z -> marginalise(z, output_kernel), filter_distributions)\n\nplt = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")\nplot!(ts, output_filter_estimate, label = \"filter estimate\")","category":"page"},{"location":"tutorial_rts/#Implementing-a-Rauch-Tung-Striebeel-smoother","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebeel smoother","text":"","category":"section"},{"location":"tutorial_rts/","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"tutorial_rts/#Setting-up-the-environment-and-loading-some-data","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Setting up the environment and loading some data","text":"","category":"section"},{"location":"tutorial_rts/","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"using MarkovKernels\nusing Random, LinearAlgebra, Plots\n\nrng = MersenneTwister(1991)\n\ninclude(\"../../demo/sampling_implementation.jl\")\ninclude(\"../../demo/sample_trajectory.jl\")\ninclude(\"../../demo/kalman_filter_implementation.jl\")\n\noutput_plot = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")","category":"page"},{"location":"tutorial_rts/#Implementing-a-Rauch-Tung-Striebel-smoother","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"","category":"section"},{"location":"tutorial_rts/","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"function rts(\n    ys::AbstractVecOrMat,\n    init::AbstractNormal,\n    fw_kernel::AbstractNormalKernel,\n    m_kernel::AbstractNormalKernel,\n)\n    # run a Kalman filter\n    filter_distributions, loglike = kalman_filter(ys, init, fw_kernel, m_kernel)\n\n    # compute the backward kenrles for the Rauch-Tung-Striebel recursion\n    bw_kernels = NormalKernel[]\n    for m in 1:length(filter_distributions)-1\n        pred, bw_kernel = invert(filter_distributions[m], fw_kernel)\n        push!(bw_kernels, bw_kernel)\n    end\n\n    # compute the smoother estimates\n    smoother_distributions = Normal[]\n    smoother_distribution = filter_distributions[end]\n    pushfirst!(smoother_distributions, smoother_distribution)\n    for m in length(filter_distributions)-1:-1:1\n        smoother_distribution = marginalise(smoother_distribution, bw_kernels[m])\n        pushfirst!(smoother_distributions, smoother_distribution)\n    end\n\n    return smoother_distributions, filter_distributions, loglike\nend","category":"page"},{"location":"tutorial_rts/#Computing-state-estimates","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Computing state estimates","text":"","category":"section"},{"location":"tutorial_rts/","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"# Rauch-Tung-Striebel smoother\nsmoother_distributions, filter_distributions, loglike =\n    rts(ys, init, fw_kernel, m_kernel)\n\n# plotting the filter state estimates\nstate_plt = plot(\n    ts,\n    xs,\n    layout = (2, 1),\n    xlabel = [\"\" \"t\"],\n    label = [\"x1\" \"x2\"],\n    title = [\"Filter estimates of the state\" \"\"],\n)\nplot!(ts, filter_distributions, layout = (2, 1), label = [\"x1filter\" \"x2filter\"])\nplot!(ts, smoother_distributions, layout = (2, 1), label = [\"x1smoother\" \"x2smoother\"])","category":"page"},{"location":"tutorial_rts/#Computing-the-output-estimates","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Computing the output estimates","text":"","category":"section"},{"location":"tutorial_rts/","page":"Implementing a Rauch-Tung-Striebel smoother","title":"Implementing a Rauch-Tung-Striebel smoother","text":"output_filter_estimate = map(z -> marginalise(z, output_kernel), filter_distributions)\noutput_smoother_estimate = map(z -> marginalise(z, output_kernel), smoother_distributions)\n\nplt = plot(ts, outs, label = \"output\", xlabel = \"t\")\nscatter!(ts, ys, label = \"measurement\", color = \"black\")\nplot!(ts, output_filter_estimate, label = \"filter estimate\")\nplot!(ts, output_smoother_estimate, label = \"smooher estimate\")","category":"page"},{"location":"dirackernel/#DiracKernel","page":"DiracKernel","title":"DiracKernel","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"The Dirac kernel with conditional mean prameter  mu is denotd by","category":"page"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"k(ymid x) = delta(y - mu(x))","category":"page"},{"location":"dirackernel/#Types","page":"DiracKernel","title":"Types","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"AbstractDiracKernel{T}\nDiracKernel{T}","category":"page"},{"location":"dirackernel/#MarkovKernels.AbstractDiracKernel","page":"DiracKernel","title":"MarkovKernels.AbstractDiracKernel","text":"AbstractDiracKernel{T<:Number}\n\nAbstract type for representing Dirac kernels taking values in T.\n\n\n\n\n\n","category":"type"},{"location":"dirackernel/#MarkovKernels.DiracKernel","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel\n\nType for representing Dirac kernels K(y,x) = δ(y - μ(x)).\n\n\n\n\n\n","category":"type"},{"location":"dirackernel/#Type-aliases","page":"DiracKernel","title":"Type aliases","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"const AffineDiracKernel{T} = DiracKernel{T,<:AbstractAffineMap}","category":"page"},{"location":"dirackernel/#Constructors","page":"DiracKernel","title":"Constructors","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"DiracKernel(F::AbstractAffineMap)\nDiracKernel(Φ::AbstractMatrix)\nDiracKernel(Φ::AbstractMatrix, b::AbstractVector)\nDiracKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector)\nDiracKernel{T}(K::AffineDiracKernel{U}) where {T,U}","category":"page"},{"location":"dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractAffineMap}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(F::AbstractAffineMap)\n\nCreates a DiracKernel with conditional mean function F.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, Σ)\n\nCreates a DiracKernel with a linear conditional mean function given by\n\nx ↦ Φ * x.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix, AbstractVector}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, b::AbstractVector, Σ)\n\nCreates a DiracKernel with an affine conditional mean function given by\n\nx ↦ b + Φ * x.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#MarkovKernels.DiracKernel-Tuple{AbstractMatrix, AbstractVector, AbstractVector}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel(Φ::AbstractMatrix, b::AbstractVector, c::AbstractVector, Σ)\n\nCreates a DiracKernel with an affine corrector conditional mean function given by\n\nx ↦ b + Φ * (x - c).\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#MarkovKernels.DiracKernel-Union{Tuple{AffineDiracKernel{U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"DiracKernel","title":"MarkovKernels.DiracKernel","text":"DiracKernel{T}(K::AffineDiracKernel{U}) where {T,U}\n\nComputes a Dirac kernel of eltype T from the Dirac kernel K if T and U are compatible. That is T and U must both be Real or both be Complex.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#Basics","page":"DiracKernel","title":"Basics","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"mean(K::DiracKernel)","category":"page"},{"location":"dirackernel/#Statistics.mean-Tuple{DiracKernel}","page":"DiracKernel","title":"Statistics.mean","text":"mean(K::AbstractDiracKernel)\n\nComputes the conditonal mean function of the Dirac kernel K. That is, the output is callable.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#Conditioning-and-sampling","page":"DiracKernel","title":"Conditioning and sampling","text":"","category":"section"},{"location":"dirackernel/","page":"DiracKernel","title":"DiracKernel","text":"condition(K::DiracKernel, x)\nrand(::AbstractRNG, K::AbstractDiracKernel, x::AbstractVector)\nrand(K::AbstractDiracKernel, x::AbstractVector)","category":"page"},{"location":"dirackernel/#MarkovKernels.condition-Tuple{DiracKernel, Any}","page":"DiracKernel","title":"MarkovKernels.condition","text":"condition(K::AbstractDiracKernel, x)\n\nReturns a Dirac distribution corresponding to the Dirac kernel K evaluated at x.\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#Base.rand-Tuple{Random.AbstractRNG, AbstractDiracKernel, AbstractVector}","page":"DiracKernel","title":"Base.rand","text":"rand(::AbstractRNG, K::AbstractDiracKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Dirac kernel K using the random number generator RNG. Equivalent to mean(K)(x).\n\n\n\n\n\n","category":"method"},{"location":"dirackernel/#Base.rand-Tuple{AbstractDiracKernel, AbstractVector}","page":"DiracKernel","title":"Base.rand","text":"rand(K::AbstractDiracKernel, x::AbstractVector)\n\nComputes a random vector conditionally on x with respect the the Dirac kernel K using the random number generator Random.GLOBAL_RNG. Equivalent to mean(K)(x).\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#Covariance-Parameter","page":"Covariance parametrisations","title":"Covariance Parameter","text":"","category":"section"},{"location":"covariance_parameter/","page":"Covariance parametrisations","title":"Covariance parametrisations","text":"CurrentModule = MarkovKernels","category":"page"},{"location":"covariance_parameter/","page":"Covariance parametrisations","title":"Covariance parametrisations","text":"In MarkovKernels.jl a covariance matrix is assumed to be of the following type union.","category":"page"},{"location":"covariance_parameter/","page":"Covariance parametrisations","title":"Covariance parametrisations","text":"const CovarianceParameter{T} = Union{HermOrSym{T},UniformScaling{T},Factorization{T}}","category":"page"},{"location":"covariance_parameter/#Functions","page":"Covariance parametrisations","title":"Functions","text":"","category":"section"},{"location":"covariance_parameter/","page":"Covariance parametrisations","title":"Covariance parametrisations","text":"lsqrt(J::UniformScaling)\nlsqrt(A::AbstractMatrix)\nstein(Σ, Φ::AbstractMatrix)\nstein(Σ, Φ::AbstractMatrix, Q)\nschur_reduce(Π, C::AbstractMatrix)\nschur_reduce(Π, C::AbstractMatrix, R)","category":"page"},{"location":"covariance_parameter/#MarkovKernels.lsqrt-Tuple{LinearAlgebra.UniformScaling}","page":"Covariance parametrisations","title":"MarkovKernels.lsqrt","text":"lsqrt(A::CovarianceParameter)\n\nComputes a square 'matrix' L such that A = L*L'. L need not be a Cholesky factor.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.lsqrt-Tuple{AbstractMatrix}","page":"Covariance parametrisations","title":"MarkovKernels.lsqrt","text":"lsqrt(A::AbstractMatrix)\n\nEquivalent to cholesky(A).L\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.stein-Tuple{Any, AbstractMatrix}","page":"Covariance parametrisations","title":"MarkovKernels.stein","text":"stein(Σ::CovarianceParameter, Φ::AbstractMatrix)\n\nComputes the output of the stein  operator\n\nΣ ↦ Φ * Σ * Φ'.\n\nGenerally, the type of Σ determines the type of the output. The exception is the case when Q is a Factorization and Σ is of type Union{HermOrSym{T,Diagonal{T,V}},UniformScaling{T}}, in which case Q determines the type of the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.stein-Tuple{Any, AbstractMatrix, Any}","page":"Covariance parametrisations","title":"MarkovKernels.stein","text":"stein(Σ::CovarianceParameter, Φ::AbstractMatrix, Q::CovarianceParameter)\n\nComputes the output of the stein  operator\n\nΣ ↦ Φ * Σ * Φ' + Q.\n\nGenerally, the type of Σ determines the type of the output. The exception is the case when Q is a Factorization and Σ is of type Union{HermOrSym{T,Diagonal{T,V}},UniformScaling{T}}, in which case Q determines the type of the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.schur_reduce-Tuple{Any, AbstractMatrix}","page":"Covariance parametrisations","title":"MarkovKernels.schur_reduce","text":"schur_reduce(Π::CovarianceParameter, C::AbstractMatrix)\n\nReturns the tuple (S, K, Σ) associated with the following (block) Schur reduction:\n\n[C*Π*C' C*Π; Π*C' Π] = [0 0; 0 Σ] + [I; K]*(C*Π*C')*[I; K]'\n\nIn terms of Kalman filtering, Π is the predictive covariance, C the measurement matrix, and R the measurement covariance, then S is the marginal measurement covariance, K is the Kalman gain, and Σ is the filtering covariance.\n\nGenerally, the type of Π determines the type of the output. The exception is the case when R is a Factorization and Π is of type Union{HermOrSym{T,Diagonal{T,V}},UniformScaling{T}}, in which case R determines the type of the output.\n\n\n\n\n\n","category":"method"},{"location":"covariance_parameter/#MarkovKernels.schur_reduce-Tuple{Any, AbstractMatrix, Any}","page":"Covariance parametrisations","title":"MarkovKernels.schur_reduce","text":"schur_reduce(Π::CovarianceParameter, C::AbstractMatrix, R::CovarianceParameter)\n\nReturns the tuple (S, K, Σ) associated with the following (block) Schur reduction:\n\n[CΠC' + R CΠ; ΠC' Π] = [0 0; 0 Σ] + [I; K](CΠC' + R)[I; K]'\n\nIn terms of Kalman filtering, Π is the predictive covariance, C the measurement matrix, and R the measurement covariance, then S is the marginal measurement covariance, K is the Kalman gain, and Σ is the filtering covariance.\n\nGenerally, the type of Π determines the type of the output. The exception is the case when R is a Factorization and Π is of type Union{HermOrSym{T,Diagonal{T,V}},UniformScaling{T}}, in which case R determines the type of the output.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MarkovKernels\nusing MarkovKernels","category":"page"},{"location":"#MarkovKernels","page":"Home","title":"MarkovKernels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MarkovKernels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
